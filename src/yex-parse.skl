fputs("
\n", output);
>/* vim: syntax=c
>*/
>static void write_states(struct yex_parse_state *state, long rule,
>		FILE *output);
>int yex_parse_char(struct yex_parse_state *state, int c, FILE *output) {
>COROUTINE_START(state->parse_char_progress);
>state->arena = arena_new();

/* definitions */
>parse_definitions(state, COROUTINE_RESET, output);
>for (;;) {
>	COROUTINE_GETC;
>	switch (parse_definitions(state, c, output)) {
>	case 0:
>		continue;
>	case -1:
>		goto parsed_definitions;
>	case 1:
>		state->ret = 1;
>		goto ret;
>	}
>}
>parsed_definitions:

>/* also, let's parse the rules while we're at it */
>parse_rules(state, COROUTINE_RESET);
>for (;;) {
>	COROUTINE_GETC;
>	switch (parse_rules(state, c)) {
>	case 0:
>		continue;
>	case -1:
>		goto parsed_rules;
>	case 1:
>		state->ret = 1;
>		goto ret;
>	}
>}
>parsed_rules:

#include <stdio.h>
#include <stdlib.h>

/* visibility macros, may be overwritten by the definitions section */
#ifndef YYLEX_V
#define YYLEX_V
#endif

#ifndef YYMORE_V
#define YYMORE_V static
#endif

#ifndef YYLESS_V
#define YYLESS_V static
#endif

#ifndef YYINPUT_V
#define YYINPUT_V static
#endif

#ifndef YYUNPUT_V
#define YYUNPUT_V static
#endif

#ifndef YYUNPUT_V
#define YYUNPUT_V static
#endif

#ifndef YYTEXT_V
#define YYTEXT_V
#endif

#ifndef YYIN_V
#define YYIN_V
#endif

#ifndef YYLENG_V
#define YYLENG_V
#endif

#ifndef YYRESET_V
#define YYRESET_V static
#endif

#ifndef YYERROR_V
#define YYERROR_V static
#endif

/* variable definitions */

/* you could change this value in the definitions section if you wanted to, but
 * there's really no reason to do that instead of using %o */
#ifndef YYTEXT_SIZE
>fprintf(output, "#define YYTEXT_SIZE %ld\n", state->output_size);
#endif

>if (state->yytext_type == POINTER) {
	static char yytext_data[YYTEXT_SIZE]
	YYTEXT_V char *yytext = yytext_data;
>} else {
	YYTEXT_V char yytext[YYTEXT_SIZE]
>}

YYLENG_V int yyleng = 0;
YYIN_V FILE *yyin = stdin;

/* circular buffer to store read data */
static unsigned char yybuf[YYTEXT_SIZE];
static int yybuf_start = 0;
static int yybuf_len = 0;

/* standard function definitions */
YYLEX_V int yylex(void);
YYMORE_V int yymore(void);
YYLESS_V int yyless(int n);
YYINPUT_V int input(void);
YYUNPUT_V int unput(int c);

/* extension definitions */
YYRESET_V int yyreset(void);
YYERROR_V char *yyerror(int code);

/* helper functions */
static int yyinput(void); /* gets an input and writes it to yytext */
static void yyfix_start(void);

/* state definitions */
>state->j = 0;
>for (state->i = 0; state->i < state->sh_states_count; ++state->i) {
>	fprintf(output, "#define %s %ld\n",
>			state->sh_states[state->i], state->j++);
>}
>for (state->i = 0; state->i < state->ex_states_count; ++state->i) {
>	fprintf(output, "#define %s %ld\n",
>			state->ex_states[state->i], state->j++);
>}
static int yystate = INITIAL;

#define YYERROR_SUCCESS 0
#define YYERROR_BUFF_FULL 1
#define YYERROR_INV_ARG 2

/* boolean indicating that yymore was called */
static int yyappend = 0;

/* boolean indicating that '^' anchors should be matched */
static int yyanchor = 1;

#define BEGIN yystate =
#define ECHO fputs(yytext, stdout)

YYLEX_V int yylex(void) {
	int ch;

>for (state->i = 0; state->i < state->rules_count; ++state->i) {
>	/* dfa states */
>	fprintf(output, "long state_%ld = 0;\n", (long) state->i);
>	/* match lengths */
>	fprintf(output, "int mlen_%ld = -1;\n", (long) state->i);
>}

	for (;;) {
		ch = yyinput();
>for (state->i = 0; state->i < state->rules_count; ++state->i) {
		switch (yystate) {
>	write_states(state, state->i, output);
>	fprintf(output, "switch (state_%ld:) {\n", (long) state->i);

>#define this_dfa (state->rules[state->i]->re_dfa)
>	for (state->j = 0; (long) state->j < this_dfa->num_nodes; ++state->j) {
>		fprintf(output, "case %ld:\n", (long) state->j);
				switch (ch) {

>		for (state->k = 0; (long) state->k < this_dfa->num_items;
>					++state->k) {
>			state->t = this_dfa->nodes[state->j].links[state->k];
>			if (state->t == -1) {
>				continue;
>			}
>			fprintf(output, "case %ld:\n", state->k);
>			fprintf(output, "state_%ld = %ld;\n",
>					(long) state->i,
>					state->t);
>			fputs("break;\n", output);
>		}
>	}
				default:
>fprintf(output, "state_%ld = -1;\n", state->i);
					break;
				}
>}
>#undef this_dfa
			}
		}
	}
}

#undef BEGIN
#undef ECHO

>for (state->i = 0; state->i < state->sh_states_count; ++state->i) {
>	fprintf(output, "#undef %s\n", state->sh_states[state->i]);
>}
>for (state->i = 0; state->i < state->ex_states_count; ++state->i) {
>	fprintf(output, "#undef %s\n", state->ex_states[state->i]);
>}

YYMORE_V int yymore(void) {
	yyappend = 1;
	return YYERROR_SUCCESS;
}

YYLESS_V int yyless(int n) {
	int i, r;

	if (n < 0 || n >= yyleng) {
		return YYERROR_INV_ARG;
	}

	for (i = yyleng-1; i >= n; --i) {
		r = unputc(yytext[i]);
		if (r != YYERROR_SUCCESS) {
			return r;
		}
	}
	yytext[n] = '\0';
	return YYERROR_SUCCESS;
}

YYINPUT_V int input(void) {
	int ret;

	if (yybuf_len > 0) {
		ret = yybuf[yybuf_start];
		++yybuf_start;
		yyfix_start();
	} else {
		ret = fgetc(yyin);
	}

	if (ret == EOF) {
		return 0;
	}
	return ret;
}

static int yyinput(void) {
	if (yyleng+1 >= YYTEXT_SIZE) {
		return YYERROR_BUFF_FULL;
	}
	yytext[yyleng++] = input();
	yytext[yyleng] = '\0';
	return YYERROR_SUCCESS;
}

YYUNPUT_V int unput(int c) {
	if (yybuf_len >= YYTEXT_SIZE) {
		return YYERROR_BUFF_FULL;
	}
	--yybuf_start;
	++yybuf_len;
	yyfix_start;
	yybuf[yybuf_start] = c;
	return YYERROR_SUCCESS;
}

YYRESET_V int yyreset(void) {
	yybuf_start = 0;
	yybuf_len = 0;
	yystate = YYSTATE_DEFAULT;
	yyappend = 0;
	yyanchor = 1;
	return YYERROR_SUCCESS;
}

YYERROR_V char *yyerror(int code) {
	switch (code) {
	case YYERROR_SUCCESS: return "Success";
	case YYERROR_BUFF_FULL: return "Input buffer is full";
	case YYERROR_INV_ARG: return "Invalid input";
	default: return "Unknown error code";
	}
}

static void yyfix_start(void) {
	div_t d;
	d = div(yybuf_start, YYTEXT_SIZE);
	yybuf_start = d.rem;
	while (yybuf_start < 0) {
		yybuf_start += YYTEXT_SIZE;
	}
}

/* user subroutines */
>for (;;) {
>	COROUTINE_GETC;
>	if (c == COROUTINE_EOF) {
>		break;
>	}
>	fputc(c, output);
>}

>state->ret = -1;
>ret:
>arena_free(state->arena);
>state->arena = NULL;
>COROUTINE_RET(state->ret);
>COROUTINE_END;
>}
>
>static void write_states(struct yex_parse_state *state, long rule,
>		FILE *output) {
>	struct yex_parse_rule *r;
>	size_t i;
>	char *s;
>
>	r = state->rules[rule];
>
>	if (r->states == NULL) {
>		for (i = 0; i < state->sh_states_count; ++i) {
>			fprintf(output, "case %s:\n", state->sh_states[i]);
>		}
>		return;
>	}
>
>	s = r->states;
>
>	while (*s != '\0') {
>		fputs("case ", output);
>		while (*s != '\0' && *s != ',') {
>			fputc(*s, output);
>			++s;
>		}
>		fputs(":\n", output);
>		if (*s == ',') {
>			++s;
>		}
>	}
>}
